<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript</title>
</head>
<body>
    <h1>JavaScript 函数</h1>
    <h2>匿名函数</h2>
    <p>匿名函数（函数没有名称），函数储存在变量中，不需要函数名称，通常通过变量名来调用</p>
    <p id="demo"></p>
    <script>
        var x = function(a, b) {
            return a + b;
        }
        var z = x(1, 2);
        document.getElementById("demo").innerHTML = z;
    </script>
    <h2>构造函数（不常用）</h2>
    <p id="demo2"></p>
    <script>
        var myFunction = new Function("a","b","return a + b");
        var x = myFunction(1,2);
        document.getElementById("demo2").innerHTML = z;
    </script>
    <h2>自调用函数</h2>
    <p id="demo3"></p>
    <script>
        (function(){
            var x = "Hello!!";
            document.getElementById("demo3").innerHTML = x;
        })()
    </script>
    <h2>箭头函数</h2>
    <p>
        ES6 新增了箭头函数  
    </p>
    <p id="demo11"></p>
    <p id="demo12"></p>
    <p id="demo13"></p>
    <script>
        // 没有参数的箭头函数
        var f = () => 100;
        document.getElementById("demo11").innerHTML = f();
        // 单一参数
        var f2 = a => a + 10;
        document.getElementById("demo12").innerHTML = f2(100);
        // 多个参数
        var f3 = (a, b) => a + b;
        document.getElementById("demo13").innerHTML = f3(100,20);
    </script>
    <h2>函数参数</h2>
    <p id="demo15"></p>
    <p id="demo16"></p>
    <p id="demo17"></p>
    <script>
        // 默认参数 1 
        function fn1(x, y) {
            if (y == undefined) {
                y = 100;
            }
            return x + y;
        }
        document.getElementById("demo15").innerHTML = fn1(1)
        // 默认参数 2
        function fn2(x, y) {
            y = y || 100;
            return x + y;
        }
        document.getElementById("demo16").innerHTML = fn2(1)
        // 默认参数 3
        function fn3(x, y = 100) {
            return x + y;
        }
        document.getElementById("demo17").innerHTML = fn3(1)
        // arguments 对象
        function fn4(x , y) {
            if (arguments.length > 0) {
                for (i=0; i<arguments.length; i++) {
                    console.log(arguments[i]);
                }
            }
        }
        fn4(100,101);
    </script>
    <h2>变量声明时如果不使用 var 关键字，那么它就是一个全局变量，即便它在函数内定义。</h2>
    <p id="demo18"></p>
    <p id="demo19"></p>
    <script>
        function a() {
            var c = 100;
            d = 100;
        }
        a();
        document.getElementById("demo19").innerHTML = "d = " + d;

    </script>
    <h2>内嵌函数</h2>
    <p id="demo20"></p>

    <script>
        function add() {
            var counter = 0;
            function plus() {counter += 1};
            plus();
            return counter;
        }
        document.getElementById("demo20").innerHTML = add();
    </script>

    <h2>JavaScript 闭包</h2>
    <p>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。

        直观的说就是形成一个不销毁的栈环境。</p>
    <xmp>
        var add = (function () {
            var counter = 0;
            return function () {return counter += 1;}
        })();
         
        add();
        add();
        add();
         
        // 计数器为 3
    </xmp>
    <p>
        变量 add 指定了函数自我调用的返回字值。<br>

自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。<br>

add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。<br>

这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。<br>

计数器受匿名函数的作用域保护，只能通过 add 方法修改。<br>
    </p>
    <p>局部变量计数。</p>
    <button type="button" onclick="myFunction()">计数!</button>
    <p id="demo0">0</p>
    <script>
    var add = (function () {
        var counter = 0;
        return function () {return counter += 1;}
    })();
    function myFunction(){
        document.getElementById("demo0").innerHTML = add();
    }
    </script>
</body>
</html>